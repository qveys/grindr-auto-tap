name: Update PR Description

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update'
        required: true
        type: number

permissions:
  pull-requests: write
  contents: read

jobs:
  update-pr-description:
    runs-on: ubuntu-latest
    if: (github.event.pull_request.draft == false || github.event_name == 'workflow_dispatch') || (github.event.action == 'closed' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.event.pull_request.base.ref || github.ref }}

      - name: Get PR information and parse markers
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number || context.payload.inputs?.pr_number;
            const isClosed = github.event.action === 'closed' && context.payload.pull_request?.merged === true;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // ============ PRÃ‰SERVER LE CONTENU UTILISATEUR ============
            let userContent = '';
            const currentBody = pr.body || '';
            
            // Parser les marqueurs USER_CONTENT
            const userContentMatch = currentBody.match(
              /<!-- USER_CONTENT_START -->([\s\S]*?)<!-- USER_CONTENT_END -->/
            );
            
            if (userContentMatch) {
              // Contenu existant trouvÃ©
              userContent = userContentMatch[1];
            } else {
              // PremiÃ¨re crÃ©ation : extraire tout ce qui n'est pas AUTO_GENERATED
              const autoMatch = currentBody.match(
                /<!-- AUTO_GENERATED_START -->([\s\S]*?)<!-- AUTO_GENERATED_END -->/
              );
              if (autoMatch) {
                userContent = currentBody.substring(0, autoMatch.index).trim();
              } else {
                // Aucun marqueur trouvÃ© : c'est un nouveau contenu
                userContent = currentBody.trim();
              }
            }
            
            // ============ GÃ‰NÃ‰RER LES SECTIONS AUTO ============
            
            // 1. Calculer les statistiques
            const stats = {
              filesChanged: files.length,
              additions: files.reduce((sum, f) => sum + f.additions, 0),
              deletions: files.reduce((sum, f) => sum + f.deletions, 0),
              commits: commits.length
            };
            
            // 2. Construire l'arbre des fichiers avec les stats
            const fileMap = {};
            files.forEach(f => {
              fileMap[f.filename] = { additions: f.additions, deletions: f.deletions };
            });
            
            const fileTree = Object.keys(fileMap).sort();
            
            function buildFileTree(files, fileStats) {
              const root = {};
              
              files.forEach(file => {
                const parts = file.split('/');
                let current = root;
                
                parts.forEach((part, i) => {
                  const isFile = i === parts.length - 1;
                  
                  if (!current[part]) {
                    current[part] = isFile ? { _isFile: true, _stats: fileStats[file] } : {};
                  }
                  
                  if (isFile) {
                    current[part]._isFile = true;
                    current[part]._stats = fileStats[file];
                  }
                  
                  current = current[part];
                });
              });
              
              return formatTree(root);
            }
            
            function formatTree(node, prefix = '', isLast = true) {
              let result = '';
              const entries = Object.entries(node)
                .filter(([key]) => !key.startsWith('_'))
                .sort(([a], [b]) => {
                  const aIsFile = node[a]._isFile;
                  const bIsFile = node[b]._isFile;
                  if (aIsFile === bIsFile) return a.localeCompare(b);
                  return aIsFile ? 1 : -1; // Dossiers avant fichiers
                });
              
              entries.forEach(([key, value], index) => {
                const isLastEntry = index === entries.length - 1;
                const connector = isLastEntry ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
                const extension = isLastEntry ? '    ' : 'â”‚   ';
                
                if (value._isFile) {
                  const { additions = 0, deletions = 0 } = value._stats || {};
                  const stats = additions === 0 && deletions === 0 ? '(binary)' : `(+${additions}/-${deletions})`;
                  result += prefix + connector + key + ' ' + stats + '\n';
                } else {
                  result += prefix + connector + key + '/\n';
                  result += formatTree(value, prefix + extension, isLastEntry);
                }
              });
              
              return result;
            }
            
            const tree = buildFileTree(fileTree, fileMap);
            
            // 3. Formater la liste des commits
            const commitsList = commits
              .map(c => `- \`${c.sha.substring(0, 7)}\` â€“ ${c.commit.message.split('\n')[0]}`)
              .join('\n');
            
            // 4. GÃ©nÃ©rer le schÃ©ma Mermaid si PR fermÃ©e
            let architectureDiagram = '';
            if (isClosed) {
              architectureDiagram = generateArchitectureDiagram(files);
            }
            
            function generateArchitectureDiagram(changedFiles) {
              // Analyser les fichiers modifiÃ©s pour gÃ©nÃ©rer un diagramme architectural
              const categories = {
                components: [],
                services: [],
                utils: [],
                database: [],
                api: [],
                other: []
              };
              
              changedFiles.forEach(f => {
                const path = f.filename.toLowerCase();
                if (path.includes('component') || path.includes('view') || path.includes('page')) {
                  categories.components.push(f.filename.split('/').pop());
                } else if (path.includes('service') || path.includes('handler')) {
                  categories.services.push(f.filename.split('/').pop());
                } else if (path.includes('util') || path.includes('helper')) {
                  categories.utils.push(f.filename.split('/').pop());
                } else if (path.includes('db') || path.includes('model') || path.includes('schema')) {
                  categories.database.push(f.filename.split('/').pop());
                } else if (path.includes('api') || path.includes('route') || path.includes('middleware')) {
                  categories.api.push(f.filename.split('/').pop());
                } else {
                  categories.other.push(f.filename.split('/').pop());
                }
              });
              
              let mermaid = 'graph TD\n';
              let connections = [];
              
              // Ajouter les nÅ“uds
              if (categories.components.length > 0) {
                mermaid += '    UI["ğŸ¨ UI Components<br/>' + categories.components.slice(0, 3).join('<br/>') + '"]::ui\n';
                connections.push('UI');
              }
              
              if (categories.services.length > 0) {
                mermaid += '    SERVICES["âš™ï¸ Services<br/>' + categories.services.slice(0, 3).join('<br/>') + '"]::service\n';
                if (connections.includes('UI')) {
                  mermaid += '    UI --> SERVICES\n';
                }
                connections.push('SERVICES');
              }
              
              if (categories.api.length > 0) {
                mermaid += '    API["ğŸ”Œ API/Routes<br/>' + categories.api.slice(0, 3).join('<br/>') + '"]::api\n';
                if (connections.includes('SERVICES')) {
                  mermaid += '    SERVICES --> API\n';
                } else if (connections.includes('UI')) {
                  mermaid += '    UI --> API\n';
                }
                connections.push('API');
              }
              
              if (categories.database.length > 0) {
                mermaid += '    DB[("ğŸ—„ï¸ Database<br/>' + categories.database.slice(0, 3).join('<br/>') + '")]::db\n';
                if (connections.includes('API')) {
                  mermaid += '    API --> DB\n';
                } else if (connections.includes('SERVICES')) {
                  mermaid += '    SERVICES --> DB\n';
                }
              }
              
              if (categories.utils.length > 0) {
                mermaid += '    UTILS["ğŸ› ï¸ Utils<br/>' + categories.utils.slice(0, 2).join('<br/>') + '"]::utils\n';
                if (categories.services.length > 0) {
                  mermaid += '    SERVICES -.->|used by| UTILS\n';
                }
              }
              
              // Ajouter les styles
              mermaid += '    classDef ui fill:#e1f5ff\n';
              mermaid += '    classDef service fill:#f3e5f5\n';
              mermaid += '    classDef api fill:#fce4ec\n';
              mermaid += '    classDef db fill:#e8f5e9\n';
              mermaid += '    classDef utils fill:#fff3e0\n';
              
              return `\`\`\`mermaid\n${mermaid}\`\`\``;
            }
            
            // 5. Extraire la section Architecture du USER_CONTENT (si prÃ©sente)
            let architectureSection = '';
            const archMatch = userContent.match(
              /## ğŸ—ï¸ Architecture.*?\n\n([\s\S]*?)(?=## âœ…|$)/
            );
            
            if (archMatch) {
              architectureSection = `\n## ğŸ—ï¸ Architecture (Manuel)\n\n${archMatch[1].trim()}\n`;
            } else if (isClosed) {
              // Si PR fermÃ©e et pas de schÃ©ma manuel, ajouter le schÃ©ma auto-gÃ©nÃ©rÃ©
              architectureSection = `\n## ğŸ—ï¸ Architecture (Auto-gÃ©nÃ©rÃ©)\n\n${architectureDiagram}\n`;
            }
            
            // 6. Construire la section AUTO_GENERATED
            const autoGeneratedSection = `<!-- AUTO_GENERATED_START -->

## ğŸ“ Fichiers modifiÃ©s

\`\`\`
${tree.trim()}
\`\`\`

## ğŸ“Š Statistiques

| MÃ©trique | Valeur |
|----------|--------|
| Fichiers modifiÃ©s | ${stats.filesChanged} |
| Lignes ajoutÃ©es | +${stats.additions} |
| Lignes supprimÃ©es | -${stats.deletions} |
| Commits | ${stats.commits} |

## ğŸ“ Commits

${commitsList}${architectureSection}

<!-- AUTO_GENERATED_END -->`;
            
            // ============ CONSTRUIRE LA DESCRIPTION FINALE ============
            const updatedDescription = `<!-- USER_CONTENT_START -->
${userContent}
<!-- USER_CONTENT_END -->

${autoGeneratedSection}`;
            
            // 7. Mettre Ã  jour la PR
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              body: updatedDescription
            });
            
            const action = isClosed ? 'âœ… Merged' : 'ğŸ”„ Updated';
            core.info(`${action} PR description successfully`);
            core.info(`ğŸ“Š Stats: ${stats.filesChanged} files, +${stats.additions}/-${stats.deletions} lines, ${stats.commits} commits`);

      - name: Comment on PR (only on first run)
        uses: actions/github-script@v7
        if: github.event.action == 'opened'
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (prNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'ğŸ¤– The PR description has been automatically updated with detailed statistics. This section updates with each commit, and an architectural diagram will be automatically generated upon closure.'
              });
            }
