name: Check Bot Review

on:
  pull_request:
    types: [opened, synchronize, reopened, review_requested]
  pull_request_review:
    types: [submitted, edited, dismissed]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-bot-review:
    name: Verify Bot Review Exists
    runs-on: ubuntu-latest
    if: github.event.pull_request

    steps:
      - name: Check unresolved review threads via GraphQL
        id: threads
        run: |
          owner="${GITHUB_REPOSITORY_OWNER}"
          name="${GITHUB_REPOSITORY#*/}"
          number=${{ github.event.pull_request.number }}

          query='
          query($owner:String!, $name:String!, $number:Int!, $cursor:String) {
            repository(owner: $owner, name: $name) {
              pullRequest(number: $number) {
                reviewThreads(first: 100, after: $cursor) {
                  nodes {
                    isResolved
                  }
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                }
              }
            }
          }'

          cursor=null
          unresolved=0

          while : ; do
            body=$(jq -n \
              --arg q "$query" \
              --arg owner "$owner" \
              --arg name "$name" \
              --argjson number "$number" \
              --arg cursor "$cursor" \
              '{
                query: $q,
                variables: {
                  owner: $owner,
                  name: $name,
                  number: $number,
                  cursor: ($cursor | select(. != "null"))
                }
              }')

            resp=$(curl -s \
              -H "Authorization: bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              -X POST https://api.github.com/graphql \
              -d "$body")

            echo "$resp" | jq '.' >/dev/null || {
              echo "GraphQL error response:"
              echo "$resp"
              exit 1
            }

            delta=$(echo "$resp" | jq '[.data.repository.pullRequest.reviewThreads.nodes // [] | map(select(.isResolved == false))] | length')
            unresolved=$((unresolved + delta))

            has_next=$(echo "$resp" | jq '.data.repository.pullRequest.reviewThreads.pageInfo.hasNextPage // false')
            if [ "$has_next" != "true" ]; then
              break
            fi

            cursor=$(echo "$resp" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.endCursor // empty')
            if [ -z "$cursor" ]; then
              break
            fi
          done

          echo "unresolved=$unresolved" >> "$GITHUB_OUTPUT"

      - name: Update status labels based on unresolved threads
        if: github.event.pull_request
        run: |
          pr_number=${{ github.event.pull_request.number }}
          unresolved=${{ steps.threads.outputs.unresolved }}

          echo "Unresolved threads: $unresolved"

          labels_json=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/$pr_number/labels")

          new_label="status: in-progress"

          # current status:* label (if any)
          current_status=$(echo "$labels_json" | jq -r '
            map(select(.name | startswith("status:"))) 
            | .[0].name // empty')

          echo "Current status label: ${current_status:-<none>}"

          desired_status=""
          if [ "$unresolved" -gt 0 ]; then
            desired_status="$new_label"
          else
            desired_status=""
          fi

          echo "Desired status label: ${desired_status:-<none>}"

          # if no change needed, bail out
          if [ "$current_status" = "$desired_status" ]; then
            echo "Status label already correct, no change required."
            exit 0
          fi

          # remove all status:* labels ONLY if we need to change
          if [ -n "$current_status" ]; then
            status_labels=$(echo "$labels_json" | jq -r '.[].name | select(startswith("status:"))')
            for label in $status_labels; do
              echo "Removing label: $label"
              curl -s -X DELETE \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/$pr_number/labels/$label" > /dev/null
            done
          fi

          # add desired status label (if any) using POST (append)
          if [ -n "$desired_status" ]; then
            echo "Adding label: $desired_status"
            resp=$(curl -s -X POST \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{\"labels\": [\"$desired_status\"]}" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/$pr_number/labels")

            echo "Label update response: $resp"
          fi

      - name: Get last bot reviewer
        id: last_bot
        if: steps.threads.outputs.unresolved == '0'
        run: |
          pr_number=${{ github.event.pull_request.number }}
          reviews=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/$pr_number/reviews")

          # filter reviews whose author is a bot
          last_bot_login=$(echo "$reviews" | jq -r '
            map(select(.user.type == "Bot"))
            | sort_by(.submitted_at)
            | last // empty
            | .user.login // empty')

          if [ -z "$last_bot_login" ] || [ "$last_bot_login" == "null" ]; then
            # default fallback to Copilot PR reviewer
            last_bot_login="copilot-pull-request-reviewer[bot]"
          fi

          echo "login=$last_bot_login" >> "$GITHUB_OUTPUT"

      - name: Check for Bot review
        if: steps.threads.outputs.unresolved == '0'
        uses: actions/github-script@v7
        with:
          script: |
            const botLogin = '${{ steps.last_bot.outputs.login }}';

            // Get all commits in the PR
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            // Get all commits and find the latest content-changing commit
            if (!commits || commits.length === 0) {
              core.info('â„¹ï¸ No commits found in the pull request. Skipping bot review freshness check.');
              return;
            }

            // Find the latest content-changing commit that requires review
            let latestCommit = commits[commits.length - 1];
            for (let i = commits.length - 1; i >= 0; i--) {
              const c = commits[i];
              const message = c.commit.message;

              const isMerge = message.startsWith('Merge branch') || message.startsWith('Merge pull request');
              const isRevert = message.startsWith('Revert "');
              const isSkip = message.includes('[skip review]');

              if (!isMerge && !isRevert && !isSkip) {
                latestCommit = c;
                break;
              }
            }

            const latestCommitDate = new Date(latestCommit.commit.committer.date);
            core.info(`â±ï¸ Latest content commit: ${latestCommit.sha.substring(0, 7)} at ${latestCommitDate.toISOString()}`);

            // Get all reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const botReviews = reviews.filter(review =>
              review.user.login === botLogin ||
              review.user.type === 'Bot'
            );

            botReviews.sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));

            const botReview = botReviews[0];

            if (!botReview) {
              core.setFailed(`âŒ Bot review is required but not found. Please wait for ${botLogin} to review this PR.`);
            } else {
              const reviewDate = new Date(botReview.submitted_at);
              core.info(`âœ… Bot review found from ${botReview.user.login}!`);
              core.info(`ğŸ“„ Review state: ${botReview.state}`);
              core.info(`ğŸ“… Review submitted at: ${reviewDate.toISOString()}`);

              if (reviewDate < latestCommitDate) {
                core.setFailed(`âš ï¸ Bot review (${reviewDate.toISOString()}) is older than the latest commit (${latestCommitDate.toISOString()}). A new review is required after code changes.`);
              } else {
                core.info('âœ… Bot review is up-to-date with the latest commit!');
              }
            }
