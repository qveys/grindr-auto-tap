name: Check Bot Review

on:
  pull_request:
    types: [opened, synchronize, reopened, review_requested]
  pull_request_review:
    types: [submitted, edited, dismissed]
  workflow_run:
    workflows: [ "Auto-Resolve Review Comments" ]
    types:
      - completed

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-bot-review:
    name: Verify Bot Review Exists
    runs-on: ubuntu-latest
    if: github.event.pull_request != null

    steps:
      - name: Check unresolved review threads (GraphQL, paginated)
        id: threads
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            
            let pull_number = context.payload.pull_request?.number;
            if (!pull_number && context.payload.workflow_run) {
              // For workflow_run, finding the PR associated with the triggering workflow run
              const prs = context.payload.workflow_run.pull_requests;
              if (prs && prs.length > 0) {
                pull_number = prs[0].number;
              }
            }

            if (!pull_number) {
              core.setFailed("Could not determine Pull Request number from context.");
              return;
            }

            const query = /* GraphQL */ `
              query($owner:String!, $repo:String!, $number:Int!, $after:String) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $number) {
                    reviewThreads(first: 100, after: $after) {
                      nodes {
                        id
                        isResolved
                        isOutdated
                        comments(first: 1) {
                          nodes { url }
                        }
                      }
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                    }
                  }
                }
              }
            `;

            let after = null;
            const unresolved = [];

            while (true) {
              const data = await github.graphql(query, { owner, repo, number: pull_number, after });
              const threads = data.repository.pullRequest.reviewThreads;

              for (const t of (threads.nodes ?? [])) {
                if (t && t.isResolved === false) {
                  unresolved.push({
                    id: t.id,
                    url: t.comments?.nodes?.[0]?.url ?? null,
                    isOutdated: !!t.isOutdated,
                  });
                }
              }

              if (!threads.pageInfo?.hasNextPage) break;
              after = threads.pageInfo.endCursor;
              if (!after) break;
            }

            const unresolvedCount = unresolved.length;
            const unresolvedIds = unresolved.map(t => t.id);
            const unresolvedUrls = unresolved.map(t => t.url).filter(Boolean);

            core.setOutput("unresolved_count", String(unresolvedCount));
            core.setOutput("unresolved_ids", JSON.stringify(unresolvedIds));
            core.setOutput("unresolved_urls", JSON.stringify(unresolvedUrls));

            if (unresolvedCount > 0) {
              core.setFailed(
                `❌ ${unresolvedCount} unresolved review thread(s) remain.\n` +
                `IDs: ${JSON.stringify(unresolvedIds)}\n` +
                `URLs: ${unresolvedUrls.join("\n") || "(no urls found)"}`
              );
            } else {
              core.info("✅ No unresolved review threads.");
            }

      - name: Determine bot login to enforce (latest bot reviewer or fallback)
        id: bot
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            
            let number = context.payload.pull_request?.number;
            if (!number && context.payload.workflow_run) {
               const prs = context.payload.workflow_run.pull_requests;
               if (prs && prs.length > 0) {
                 number = prs[0].number;
               }
            }
            
            if (!number) {
              core.setFailed("Could not determine Pull Request number from context.");
              return;
            }

            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: number });

            const botReviews = (reviews ?? [])
              .filter(r => r?.user?.type === "Bot" && r?.submitted_at && r?.user?.login !== "github-actions[bot]")
              .sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));

            const lastBot = botReviews[0]?.user?.login ?? "";
            const fallback = "copilot-pull-request-reviewer[bot]";
            const botLogin = lastBot || fallback;

            core.setOutput("login", botLogin);
            core.info(`Bot login selected: ${botLogin}`);

      - name: Enforce bot review freshness + force Copilot review when status review-needed
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            
            let pull_number = context.payload.pull_request?.number;
            if (!pull_number && context.payload.workflow_run) {
               const prs = context.payload.workflow_run.pull_requests;
               if (prs && prs.length > 0) {
                 pull_number = prs[0].number;
               }
            }

            if (!pull_number) {
              core.setFailed("Could not determine Pull Request number from context.");
              return;
            }

            const preferredBotLogin = "${{ steps.bot.outputs.login }}";

            // 1) Get labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: pull_number,
            });

            const hasReviewNeeded = (labels ?? []).some(l => l?.name === "status: review-needed");

            // 2) Find latest "content-changing" commit
            const { data: commits } = await github.rest.pulls.listCommits({
              owner, repo, pull_number,
              per_page: 250,
            });

            if (!commits?.length) {
              core.info("ℹ️ No commits found; skipping bot freshness check.");
              return;
            }

            function isSkippableCommitMessage(msg) {
              if (!msg) return false;
              const isMerge  = msg.startsWith("Merge branch") || msg.startsWith("Merge pull request");
              const isRevert = msg.startsWith('Revert "');
              const isSkip   = msg.includes("[skip review]");
              return isMerge || isRevert || isSkip;
            }

            let latestCommit = null;
            for (let i = commits.length - 1; i >= 0; i--) {
              const c = commits[i];
              const msg = c?.commit?.message ?? "";
              if (!isSkippableCommitMessage(msg)) {
                latestCommit = c;
                break;
              }
            }

            if (!latestCommit) {
              core.info("ℹ️ All commits are skippable (merge, revert, or [skip review]). strict review check not required.");
              return;
            }

            const latestCommitDate = new Date(latestCommit.commit.committer.date);
            core.info(`⏱️ Latest content commit: ${latestCommit.sha.substring(0,7)} at ${latestCommitDate.toISOString()}`);

            // 3) Get reviews (paginate to ensure we see all reviews, not just the first 100)
            const allReviews = await github.paginate(
              github.rest.pulls.listReviews,
              {
                owner,
                repo,
                pull_number,
                per_page: 100,
              }
            );

            const botReviews = (allReviews ?? [])
              .filter(r =>
                r?.submitted_at &&
                (r?.user?.login === preferredBotLogin || r?.user?.type === "Bot")
              )
              .sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));

            const latestBotReview = botReviews[0];

            // 4) If label is present, attempt to trigger Copilot review and fail
            if (hasReviewNeeded) {
              core.warning(`status: review-needed is present → attempting to trigger bot review (${preferredBotLogin}) and failing check.`);

              // Attempt to request a review from the preferred bot via the standard GitHub REST API; success depends on whether the bot account can be requested as a reviewer.
                const botLoginSanitized = preferredBotLogin.replace('[bot]', '');
                const candidates = [botLoginSanitized, preferredBotLogin];
                const uniqueCandidates = [...new Set(candidates)];
                
                let success = false;
                for (const reviewer of uniqueCandidates) {
                  try {
                    core.info(`Attempting to request reviewer: ${reviewer}`);
                    const result = await github.rest.pulls.requestReviewers({
                      owner,
                      repo,
                      pull_number: pull_number,
                      reviewers: [reviewer]
                    });
                    
                    const requestedUsers = result.data.requested_reviewers || [];
                    if (requestedUsers.length > 0) {
                      core.info(`✅ Request code review: Success (requested ${requestedUsers.map(r => r.login).join(', ')})`);
                      success = true;
                      break; 
                    } else {
                       core.warning(`⚠️ Request for '${reviewer}' was sent but ignored (returned empty list).`);
                    }
                  } catch (error) {
                    core.info(`⚠️ Failed to request '${reviewer}': ${error.message}`);
                  }
                }

                if (!success) {
                  core.setFailed("❌ Could not request any bot reviewer. Please ensure 'copilot-pull-request-reviewer' is added as a collaborator to the repository.");
                }

              core.setFailed("❌ Bot review required (status: review-needed). Waiting for a fresh bot review.");
              return;
            }

            // 5) Normal freshness enforcement
            if (!latestBotReview) {
              core.setFailed(`❌ Bot review is required but not found. Please wait for ${preferredBotLogin} to review this PR.`);
              return;
            }

            const reviewDate = new Date(latestBotReview.submitted_at);
            core.info(`✅ Bot review found: ${latestBotReview.user.login} (${latestBotReview.state}) at ${reviewDate.toISOString()}`);

            if (reviewDate < latestCommitDate) {
              core.setFailed(
                `⚠️ Bot review is older than the latest commit.\n` +
                `Review: ${reviewDate.toISOString()}\n` +
                `Latest commit: ${latestCommitDate.toISOString()}\n` +
                `A new bot review is required after code changes.`
              );
              return;
            }

            core.info("✅ Bot review is up-to-date with the latest commit!");
